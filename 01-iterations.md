# Циклы (1 часть ?)

Начнем с тупейшого примера.
Нужно вывести `Hello, World!` 15 раз.
Понятно, что можно взять и тупо 15 раз написать
```cs
// и еще 14 таких строчек тут
Console.WriteLine("Hello, World!");
```

Естественно это решение не подходит, число 15 может в какой-то момент поменяться.
А может быть так, что число повторений будет неизвестно заранее и.т.д.
Чтобы повторять одни и те же действия, существуют __циклы__.

В каком-то абсртактном не существующем языке, мы бы для такой задачи
так бы и написали, что-то в стиле
```
// фраза переводится как
// "повторить 15 раз"
repeat 15 times {
    Console.WriteLine("Hello, World!");
}
```
Как правило подобных конструкций в современных языках не встречается.
Но даже если где-то и есть такие конструкции, то это решает очень однотипные задачи.
Чтобы в C# решить эту задачу, воспользуемся циклом while. Начнём с `while`, потом от `while`, перейдем к `for`.

Синтаксис
```cs
while (/* здесь условие */)
{
    // здесь повторяемые действия
}
```
Естественно, если в фигурных скобках одна инструкция / оператор, тогда фигурные скобки можно не писать. Хотя по правилам хорошего тона, насколько я помню в C# принято фигурные скобки всегда писать и не экономить на них.

Как это работает ?
1) Проверяем что условие внутри скобок верно, если нет - цикл завершается
2) Если оно условие истинно(т.е true), выполняются действия в фигурных скобках
3) Переход к пункту 1

Как бы мы это использовали для повторяющегося вывода ?
Ну напишем сначала __тело цикла__, с условием потом разберёмся.
Ну и немного терминов.
Тело цикла = те самые действия, которые повторяются, т.е всё что в фигурных скобках.
Итерация = один шаг цикла, одно выполенение инструкций внутри фигурных скобок.
Условие цикла = условие при котором, цикл продолжает выполняться, это то что
в круглых скобоках после while.

```cs
while (/*подумаем что тут написать*/)
{
    Console.WriteLine("Hello, World!");
}
```

Всё просто, но сейчас это даже не скомпилируется. Как сделать чтобы хотя бы скомпилировалось ?
В условие напишем true. Получим бесконечный цикл

```cs
while (true)
{
    Console.WriteLine("Hello, World!");
}
```
Можно запустить спокойно, а потом или окно с консолью закрыть или в IDE самой остановить.

Но теперь самое "сложное", надо понять что вообще делать, чтоб цикл когда-то завершился.
И тут очевидно, нам просто необходимо какое-то "состояние", которое будет изменяться, и в какой-то момент с этим состоянием будет что-то, что скажем нам, что уже цикл пора завершать. Состояние = данные = переменная(ые).

Тут конечно случай очень простой. Всё, что нужно, это поддерживать количество уже выведенных фраз.
```cs
// count = сколько раз уже вывели фразы
// изначально не выводили ни разу
// потому 0 начальное значение
int count = 0;
while (/*подумаем еще что тут написать*/)
{
    // вывод фразы, "полезные" действия
    Console.WriteLine("Hello World!");
    // а дальшем увеличиваем количество
    // раз еще 1 раз вывели фразу,
    // значит на 1 увеличили
    count = count + 1;
    // обычно пишут count++, это тоже самое, но коротко
    // тут я написал так, просто чтоб было понимание что происходит
    // никакой магии, просто число на 1 увеличилось
}
```

А что в условии писать ?
`count` отвечает за кол-во раз, которое уже вывели фразу.
Выводим мы 15 раз, т.е пока count не станет 15.
В данном случае можно в условии написать `count != 15` (count не равно 15), можно `count < 15`.
Но просто предположим, что вот взяли и написали `count <= 15`. А как проще всего проверить программу ? Чтобы не считать всю ту кучу строк и не проверять что там 15, а вдруг вообще 100 попросят, как же проверить ? Легко, заменим число 15 на число 3 допустим и посмотрим что программа выводит.


```cs
int count = 0;
// 3 поменяли на 15
// чтоб посмотреть
// выведет ли оно ровно 3 раза фразу
while (count <= 3)
{
    Console.WriteLine("Hello World!");
    count = count + 1;
}
```
Прям взяли, запустили, посмотрели.
Легко видеть, выводит 4 строки вместо 3.
В голове покрутили код

0 <= 3 ? да

 выводим фразу

 count = 0 + 1 = 1

1 <= 3 ? да

 выводим фразу

 count = 1 + 1 = 2

2 <= 3 ? да

 выводим фразу

 count = 2 + 1 = 3

3 <= 3 ? да

 выводим фразу

 count = 3 + 1 = 4

4 <= 3 ? нет, конец цикла

Ну и тут понятно что если при <= случается лишняя итерация, значит нужно <= заменить на <.

Конечно сейчас был совсем тупой и простой пример. Но суть в том, показать как работает while и как можно думать когда пишешь код, как его тестировать - т.е уменьшить числа и посмотреть решит ли код ту же самую задачу, но меньше размером и.т.д.

Еще пример

Даны натуральные (целые и больше 0) числа a и b. a не больше b.
Вывести все числа от a до b включительно.

```cs
int a = 3;
int b = 9;
// переменная
// которая будет изначально a
// затем увличиваться на 1, пока
// не выведется b - последнее число из отрезка
int i = a;
// если i меньше b
// тогда понятно - цикл надо продолжать
// если i равно b
// значит мы его еще не выводили(а выводили b-1), цикл продолжаем
while (i <= b)
{
    // вывели число
    Console.WriteLine(i);
    // перешли к следующему
    i++;
}
```
Запустить прогу, потыкать, посмотреть что будет
если в условии поставить `i < b`, если `i != b`.
В каком случае прога перестанет работать правильно ?
А в каком будет работать нормально ?

__Упражнение 1.__ a > b, нужно вывести все числа от a до b,
т.е если a = 7, b = 3, нужно вывести 7 6 5 4 3

__Упражнение 2.__ Та же задача, но выводить только нечётные числа (7 5 3).

Пример возможно интереснее.
Есть строка, в которой всегда что-то типа
"Привет Андрей" или "Добрый день Владислав" или "Hello Joe".
Для того чтобы задача была проще, считаем что каждый символ или пробел или буква.
Т.е в строке нет никаких запятых, восклицательных знаков и.т.д.
Строка может быть на русском, может на английском. Из строки нужно достать имя.
Из стадартных функций в этой задаче нужно знать только длину строки,
это s.Length, где вместо s может быть любой объект типа string.
А также помнить что к строке можно добавить другую строку, т.е
string a = "123";
string b = "456";
`a + b` это `"123456"`, также можно написать `a += b`.

Решение = заметим что имя это всегда последнее слово.
Последнее слово идёт после последнего пробела.
Нужно обязательно найти последний пробел.
Потому что за ним идёт то слово, которое нужно найти.
```cs
string text = "Good morning George";
// находим последний пробел
// запишем длину строки для удобства
int len = text.Length;
// позиция пробела
int pos = 0;
int i = 0;
// строки нумерются с 0
// классический цикл
// для прохода по всем элементам массива
// i изменяется от 0
// до длины минус 1 включительно
while (i < len) {
    // можем делать что-то с text[i]
    // i текущий индекс
    // text[i] текущий индекс
    // если встретили пробел
    if (text[i] == ' ')
        // присвоили индекс в pos
        pos = i;
    ++i; // i = i + 1, перешли к след. символу
}
// if будет выполняться для всех пробелов
// значит дойдет до последнего пробела
// и в pos будет индекс именно последнего пробела

// создадим пустую строку
string name = "";
// будем записывать туда слово
// нам нужны все символы до конца
// но помним что pos это индекс пробела
// потому увеличим pos на 1
++pos;
// и дальше пока индекс меньше длины
while (pos < len)
{
    // дописываем символ в конец word
    name += text[pos];
    // индекс переходит к следующему символу
    pos++;
}

Console.WriteLine(name);
```

__Упражнение 3.__ Проще задача, есть строка, в ней только слова разделённые пробелами. Найти первое слово. Считать что в строке нет лишних пробелов в начале / конце строки и между словами по одному пробелу ровно.

__Упражнение 4.__ Найти слово с номером number, нумерация слов с 1 естественно.
